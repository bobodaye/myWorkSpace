## 1. IO复用函数（select、poll和epoll）：

**共同点：**

1. 这三组系统调用都能<u>同时监听多个文件描述符</u>。它们将等待由timeout参数指定的<u>超时时间</u>，直到一个或者多个文件描述符上有事件发生时返回，<u>返回值是就绪的文件描述符的数量</u>。返回0表示没有事件发生。
2. 这3组函数都通过某种结构体变量来告诉内核监听哪些文件描述符上的哪些事件，并使用该结构体类型的参数来获取内核处理的结果。
3. select和poll这两个函数每次调用都返回整个用户注册的事件集合（包括就绪和未就绪的），所以<u>应用程序查找就绪文件描述符的时间复杂度为O(n)。</u>

**不同点：**

**select：**

1. 只有可读、可写和异常事件，<u>不能处理更多类型的事件</u>。
2. 由于内核对fd_set集合的修改，应用程序在<u>下次调用select函数前必须要重置3个fd_set集合</u>。
3. <u>支持的文件描述符个数仅有1024个。</u>

**poll：**     

1. 它的参数pollfd将文件描述符和事件都定义在其中，<u>任何事件都被统一处理</u>，从而使编程接口更加简单。
2. <u>再次调用poll时应用程序无需重置pollfd类型的事件集参数</u>，内核每次修改的是pollfd结构体的revents成员，而events成员保持不变。
3. <u>支持的文件描述符个数为65535个。</u>

**epoll：**

1. 在内核维护一个事件表，并提供了一个独立的系统调用epoll_ctl来控制往其中添加、删除和修改事件，这样，每次epoll_wait调用都直接从该内核事件表中取得用户注册的事件，而<u>无须反复从用户空间读入这些事件。</u>
2. epoll_wait系统调用的events参数仅返回就绪的事件，使得<u>应用程序查找就绪文件描述符的时间复杂度达到O(1)。</u>
3. <u>支持的文件描述符个数达到系统允许打开的最大文件描述符数目，即65535</u>(`cat /proc/sys/fs/file-max`)。

**小结：**

- select和poll都只能工作在相对低效的**LT模式**，而epoll则可以工作在**ET高效模式**。并且epoll还支持**EPOLLONESHOT事件**。该事件能进一步减少可读、可写和异常等事件被触发的次数。
- 从实现原理上讲，select和poll采用都是<u>轮询的方式</u>，即每次都要扫描整个文件描述符集合。epoll_wait则不同，它采用的是**回调**的方式。<u>内核检测到就绪的文件描述符时，将触发回调函数，它将该文件描述符上对应的事件插入内核就绪事件队列。</u>
- 当活动连接比较多的时候，epoll_wait的效率未必比select和poll高，因为此时回调函数被触发得过于频繁。它适用于连接数量多，但活动连接比较少的情况。

![select、poll和epoll的区别](C:\Users\SNAIL_PROGRAMMER\Desktop\Markdown\Resources\select、poll和epoll的区别.JPG)

## 2. 进程

**概念：**

**进程拥有的资源：** **内存**（代码段、堆栈段、数据段）、**打开的文件**、 **IO设备**（键盘、鼠标、磁盘和标准输入及输出）、**可执行程序**、**挂起的信号**、**处理器状态**、**内核内部数据**等。

**问题：**

1）内存为什么要划分为堆和栈？

2）  而且栈的空间比堆的空间要小？

​	①栈一般用来定义临时变量，不需要给它很大的内存。

​	②

​	③

> **堆内存：**
> **栈内存：**
>
> 1. 让编程者不必关心一些数据的生命周期，而是让操作系统负责管理，解放用户。

**写时拷贝：**一种可以推迟免除拷贝数据的技术。内核并不复制整个父进程的地址空间，而是让父子进程共享同一个拷贝（**只读方式共享**）。只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。

**进程创建：**

1. fork()会复制进程的页表以及给子进程创建唯一的进程描述符。
2. vfork()不拷贝父进程的页表项，子进程作为父进程的一个单独的线程在它的地址空间里运行，父进程被阻塞，直到子进程退出或执行exec()。子进程不能向地址空间写入。

## 3. 线程

**概念：**一个任务、程序，一个可被调度的实体。

> **内核线程：**运行在内核空间，由内核来调度。
> **用户线程：**运行在用户空间，由线程库来调度。

以上二者之间的**联系：**一个进程内核线程获得CPU使用权，它加载并运行一个用户线程。

- 所有执行线程由<u>线程库</u>[^①]管理。
- 内核仍然是把整个进程作为最小单位来调度的（一个进程的所有执行线程共享该进程的时间片，对外表现优先级相同）。

**1. 线程的实现方式：**

（1）**完全在用户空间实现线程：**

- 优点：

  - 创建和调度线程都无需内核的干预，速度快。
  - 创建很多线程，也不会对系统性能造成明显的影响。

- 缺点：

  ​	对于多处理器系统，一个进程的多个线程无法运行在不同的CPU上，因为内核是按照其<u>最小调度单位</u>来分配CPU的。

（2）**完全由内核调度的模式：**

​	将创建、调度线程的任务都交给了内核 ，优缺点刚好与完全在用户空间实现线程互换。

（3）**双层调度模式：**前两种实现模式的混合体。

**2.线程的同步机制**

1. POSIX信号量
2. 互斥锁（同步线程对共享数据的访问）
3. 条件变量，当某个共享数据到达某个值的时候，唤醒等待这个共享数据的线程。

[^①]: 现代Linux上默认使用的线程库是NPTL。

## 4. 进程多种调度算法



## 5.进程间通讯

1. **管道**

   - 有名管道
   - 无名管道

   **问题：管道和普通文件的区别：**

   **管道：**

          	1. 管道拥有2个fd
        	2. 数据在内核中

2. **套接字、RPC**

3. **信号量**

4. **共享内存**（mmap函数使用）

   1. 无需内核参与
   2. 最大3G

5. ~~消息队列~~(企业使用少)

6. **条件变量、锁**（读写锁、文件锁、意向锁、排他锁、乐观锁、悲观锁、自旋锁、RCU）

## 6.异常处理如何实现的？

1. 语法
2. 捕获方式
3. 哪些原因会导致一个线程退出？
4. 时钟中断