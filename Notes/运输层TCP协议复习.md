# 运输层TCP协议复习

---

**端口号范围：**

> **熟知端口**：0-1023
> **登记端口号**：1024-49151
> **客户端端口号**：49152-65535

**特殊的端口号：**当绑定“0”端口号时，系统会返回给一个可用的端口号。

``` 
问题1：端口号最大65535是怎么来的？

	TCP报文段首部中源端口和目的端口各占2个字节，因此最大端口号为2^16-1=65535。

问题2：当调用bind函数的时候，输入端口号为0或者-1（负数）时的结果？

	bind函数原型为：int bind(int sockfd, const struct sockaddr* my_addr, socklen_t addrlen);
其中的参数my_addr包含待绑定的server的ip和端口号。再来看struct sockaddr结构体的原型为：
struct sockaddr_in {
  	sa_family_t sin_family;
  	u_int16_t sin_port;	//端口号
  	struct in_addr sin_addr;
}
	回到我们的问题，当输入端口号为-1时，由于端口号数据类型为无符号短整型，-1会被转换成65535，所以其实相当于我们输入了65535这个端口号，而当输入的端口号为0时，会比较特殊，此时os会自动给你分配一个未被使用的端口号x。

问题3：一个服务器对外能够提供的最大连接数取决于哪些因素？

    1.listen两个队列的上限(队列由内核维护，取决于内核可用内存的大小)。
    2.应用进程能够打开文件描述符的个数。

问题4：服务器如何处理百万用户连接?需要考虑哪些问题?
	
	见下面的链接:高性能网络编程C10M并发问题。

问题5：TCP连接的发送缓存为什么要维护一个“未发送”和“未确认”？

 	1.减少网络的拥塞，未发送缓冲区可以根据网络拥塞情况动态地设定一个大小，等到足量的数据到达时，再一次性发送出去。
	2.确保传输的可靠性，数据在网络中传输有可能发生丢失，如果不维护一个“未确认”的话，那么发送的数据丢失了发送方也不知道。
  
问题6：如何获得内核缓冲区大小？

	1.cat /proc/sys/net/ipv4/tcp_rmem
	结果：4096 87380 4161536，其中87380：tcp接收缓冲区的默认值。
	
	2.cat /proc/sys/net/ipv4/tcp_wmem
	结果：4096 16384 4161536，其中16384：tcp发送缓冲区的默认值。
    
	3.cat /proc/sys/net/core/rmem_max
	结果：131071，tcp或udp接收缓冲区最大可设置值的一半。
	
	4.cat /proc/sys/net/core/wmem_max
	结果：131071，tcp或udp发送缓冲区最大可设置值的一半。

问题7：send函数什么时候会阻塞？

	发送缓存中的“未发送”已满，send函数就会一直阻塞。在阻塞模式下, send函数的过程是将应用程序请求发送的数据拷贝到发送缓存中发送就返回。但由于发送缓存的存在,表现为:如果发送缓存大小比请求发送的大小要大,那么send函数立即返回,同时向网络中发送数据;否则,send会等待接收端对之前发送数据的确认,以便腾出缓存空间容纳新的待发送数据,再返回(接收端协议栈只要将数据收到接收缓存中,就会确认,并不一定要等待应用程序调用recv),如果一直没有空间能容纳待发送的数据,则一直阻塞;

问题8：recv函数什么时候会阻塞？

	recv函数读取时，若接收缓冲区的数据为空，则它就一直阻塞，知道内核检测到有数据来时，recv函数才会返回。
```

[1.高性能网络编程经典问题C10K][http://www.52im.net/thread-566-1-1.html]

[2.高性能网络编程C10M并发问题][http://www.52im.net/thread-568-1-1.html]

## 1.TCP的运输连接管理

TCP面向连接，用来传送TCP报文的。

**1.TCP的连接建立**

**关键词：**传输控制块(TCB)[^1]，CLOSED，SYN-SENT，SYN-RCVD，ESTABLISHED，三次握手

**考点：**
```
问题9.为什么TCP建立连接需要三次握手?

假设有客户端A发送连接请求报文到服务器B，由于网络阻塞，连接报文到达服务器B时，已经超出A的连接释放时间，B接收到该报文后会以为收到了新的连接请求，它就会给A回复ACK确认包，如果不采用三次握手，那么B误以为和A的连接建立成功，一直等待A发来数据，而有了三次握手，这种情况就可以避免，A收到B的ACK报文便不予理睬，这样就避免了B一直等待A的资源，造成浪费。
```
**保活计时器(Keepalive timer)：**检查客户端和服务器之间的连接是否保持。

---

**2.TCP的连接释放**

关键词：半关闭状态，FIN-WAIT-1，FIN-WAIT-2，LAST-ACK，TIME-WAIT，时间等待计时器

**半关闭状态**是指客户端不再向服务器发送数据，而还可以继续接收来自服务器的数据。

```
问题10.为什么Client在TIME-WAIT状态必须等待2MSL的时间？

   第一，为了保证A发送的最后一个ACK报文段能够到达B。
   第二，A在发送完最后一个ACK报文段后，再经过时间2MSL(Maximum Segment Lifetime)，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。
```
---
**3.TCP的有限状态机**

```
问题11.TCP两个客户端同时发起连接，状态变迁如下：

CLOSED-->SYN-SENT-->SYN-RCVD-->ESTABLISHED
```
[^1]: ①**传输控制块**(Transmission Control Block)存储了每一个连接中的一些重要信息，如：TCP连接表，到发送和接受缓存的指针，到重传队列的指针，当前的发送和接受序号。