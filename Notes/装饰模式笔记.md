2017.10.6

**设计模式学习笔记--装饰模式**

## 1.模式定义

装饰模式：动态地给一个对象添加一些额外的职责/功能，它比生成子类实现更加灵活。

## 2.模式动机

有两种方式给一个类或者对象增加功能：

- 继承方式,通过继承来扩展父类的功能，但这种方法是静态的，用户不能控制增加行为的方式和时机。

- 关联方式,将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，这个嵌入的对象被称为装饰器(Decorator)。

## 3.模式结构

- Component: 抽象构件
- ConcreteComponent: 具体构件
- Decorator: 抽象装饰类
- ConcreteDecorator: 具体装饰类

![Decorator](./Res/_static/Decorator.jpg)

时序图:

![seq_Decorator](./Res/_static/seq_Decorator.jpg)

## 4.模式分析

**优点：**

- 松耦合，关联关系使得系统具有较低的耦合度，使得系统维护更加方便。

- 灵活性，使用装饰模式实现扩展比继承更加灵活，用户可以通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象。

- 独立性，系统和核心职责和装饰功能分离，用户可以根据需要添加装饰类，而不必关心其它部分，符合“开闭原则”。

- 易用性，可通过配置文件添加和修改装饰器，而不必修改原有客户代码。

**缺点：**

- 复杂性，由于额外增加了许多的装饰类，而且使用装饰模式时会产生很多小对象（具体装饰类对象）加大了学习和理解的难度。

- 易错性，对于装饰很多次的对象，在调试时寻找错误需要逐级检查，较为麻烦。

## 5.适用环境

在以下情况可以使用装饰模式:

第一种：在不影响其它对象的情况下，以动态、透明的方式给单个对象添加职责。

第二种：1)当不能采用继承的方式对系统进行扩充 2)采用继承不利于系统扩展和维护时。

不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）。

## 6.模式扩展

装饰模式需要注意以下两点：

1. 一个装饰类提供的接口必须和被装饰类的接口保持一致，这样对客户端来说装饰前后的对象可以一致对待。

2. 尽量把装饰功能放在装饰类，具体构件类只写一些核心逻辑，二者负责的功能分清楚。

学会灵活变通，如果只有具体构件列而没有抽象构件类，那么抽象装饰类也可以直接继承具体的构件类。

参考文章链接：

1）http://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/decorator.html